<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Equipe Átomos</title>
  <link rel="stylesheet" href="./assets/css/style.css" />
</head>

<body>
  <div class="container">
    <div class="navbar">
      <a href="#home">Home</a>
      <div class="dropdown">
        <button class="dropbtn">
          Seminário
          <i class="fa fa-caret-down"></i>
        </button>
        <div class="dropdown-content">
          <a href="#tema">Tema</a>
          <a href="#modelagem">Modelagem</a>
          <a href="./relatorio">Relatório</a>
        </div>
      </div>
      <div class="dropdown">
        <button class="dropbtn">
          Laboratórios
          <i class="fa fa-caret-down"></i>
        </button>
        <div class="dropdown-content">
          <a href="#lab01">Lab 01</a>
          <a href="#lab02">Lab 02</a>
          <a href="#lab03">Lab 03</a>
          <a href="#lab05">Lab 05</a>
          <a href="#lab06">Lab 06</a>
        </div>
      </div>
    </div>

    <br />

    <header id="home">
      <h1>
        ESZI017-17SA - FPG - 2022.3<br />Fundamentos de Processamento Gráfico
      </h1>
      <h2>Turma A1 - noturno</h2>
    </header>

    <section class="box-content">
      <h2>Integrantes da equipe</h2>

      <p>BRUNO ARAUJO SANTOS DO NASCIMENTO - 11201720606</p>
      <p>LUIZ EDUARDO GRACINDO SILVA - 11201921251</p>
      <p>MATHEUS VICTOR SOARES DE ARAUJO - 11201920270</p>
      <p>VINICIUS SOUZA DE OLIVEIRA - 11201920654</p>
      <p>VIVIANE COPEDE - 11201722075</p>
    </section>

    <h2>Relatórios</h2>

    <section class="box-content" id="tema">
      <div>
        <h2>Seminário S1 - TEMA</h2>
        <p>
          Nossa equipe pretende representar de forma didática o funcionamento
          de um átomo. Para a primeira entrega pensamos em representar algum
          modelo atômico e em seguida simular algum evento como fissão, fusão
          ou decaimento.
        </p>
      </div>
    </section>

    <section class="box-content" id="modelagem">
      <div>
        <h2>Seminário - Modelagem</h2>
        <p>
          O modelo atômico escolhido por nossa equipe foi o
          <b>Modelo de Bohr</b>. Apesar de ser um modelo mais simples ele foi
          capaz de fazer previsões acerca de diversas caracteristicas do átomo
          de hidrogênio sendo relevante até os dias de hoje não somente como
          uma maneira mais didática de introduzir o tema, mas também para
          fazer estimativas mais simples. Além disso, o Modelo de Bohr é
          bastante visual e com fórmulas bem definidas sobre o comportamento
          do elétron ao redor do núcleo sendo assim um ótimo modelo para ser
          representado através de técnicas de computação gráfica.
        </p>

        <p>
          Uma representação gráfica do modelo é apresentada na imagem a
          seguir:
        </p>

        <img src="./assets/img/seminario/Bohr_atom_model.png" alt="Modelo de Bohr" />

        <p>
          Para calular o raio e velocidade dos elétron vamos utilizar as
          fórmulas a seguir:
        </p>

        <img src="./assets/img/seminario/formulas.png" alt="Modelo de Bohr formulas" />

        <p>
          Fonte:
          <a href="https://pt.wikipedia.org/wiki/%C3%81tomo_de_Bohr"
            target="_blank">https://pt.wikipedia.org/wiki/%C3%81tomo_de_Bohr</a>
        </p>

        <p>
          Para desenvolver nosso programa seguiremos uma configuração bastante
          semelhante aos projetos do lab 03. Após o setup básico de janela e
          cameras vamos adicionar as funções <b>glutDisplayFunc</b> para
          desenhar nosso modelo e <b>glutIdleFunc</b> para redesenhar o
          display e fazer a rotacão do elétron em torno do núcleo.
        </p>

        <p>
          O diagrama de blocos a seguir representa de maneira resumida o
          funcionamento do nosso sistema:
        </p>

        <img src="./assets/img/seminario/modelo2.png" alt="Modelo de Bohr formulas" />

        <p>
          Link do diagrama:
          <a href="https://excalidraw.com/#json=eNRvKrxhmFqp-nWsXP2bT,FnVxz3dBhXMesOdVz5yBHw"
            target="_blank">https://excalidraw.com/#json=eNRvKrxhmFqp-nWsXP2bT,FnVxz3dBhXMesOdVz5yBHw</a>
        </p>
      </div>
    </section>

    <section class="box-content" id="lab01">
      <div>
        <h2>Lab01: OpenGL linux</h2>

        <p>Resumo dos passos que foram executados:</p>

        <h3>1) Configurar o ambiente:</h3>

        <ul class="topic-list">
          <li>criar novo usuario com permissão de administrador no OS</li>
          <li>baixar as bibliotecas openGL e outras dependencias</li>
          <li>baixar o arquivo modelo do experimento</li>
        </ul>

        <h3>2) Compilar e executar o programa</h3>

        <ul class="topic-list">
          <li>compilar o arquivo C</li>
          <li>executar o programa a partir do terminal com</li>
          <li>
            analisar as figuras geradas e comparar com o código do arquivo.
          </li>
          <li>printar algumas amostras.</li>
        </ul>

        <p>
          Para fazer todos os passos seguimos o PDF disponibilizado no Moodle.
          Aqui no site não vamos colocar a parte de criação de um novo usuário
          admin porque é um processo especifico para os computadores da
          universidade.
        </p>

        <h2>Instalação</h2>
        <p>
          Após acessar o usuário admin podemos começar a instalação dos
          programas. Para isso devemos primeiro abrir o terminal usando o
          comando <b>CTRL+SHIFT+T</b> e digitar os seguintes comandos em
          ordem:
        </p>

        <p class="code">
          sudo apt-get update<br /><br />

          sudo apt-get install build-essential<br /><br />

          sudo apt upgrade<br /><br />

          sudo apt-get install g++ freeglut3-dev buildessential libx11-dev
          libxmu-dev libxi-dev libglu1-mesa libglu1-mesa-dev<br /><br />

          sudo apt-get install geany<br /><br />
        </p>

        <h2>Compilar</h2>

        <p>
          Após instalar as libs podemos baixar o arquivo
          <b>lesson5.cpp</b> disponibilizado no Moodle e rodar o seguinte
          comando para compilar o programa:
        </p>
        <p class="code">
          gcc -o &#60;your_file&#62; &#60;your_file&#62;.cpp -lglut -lGL -lGLU
        </p>

        <p>
          O arquivo compilado será gerado com o nome <b>test</b> que foi o que
          passamos no parametro <b>-o</b>
          rodando o seguinte comando:
        </p>

        <p class="code">./&#60;your_file&#62;</p>

        <h2>Execução</h2>

        <div class="grid-imgs">
          <img src="./assets/img/lab01/img/img-bruno.png" alt="bruno" />
          <img src="./assets/img/lab01/img/img-eduardo.png" alt="eduardo" />
          <img src="./assets/img/lab01/img/img-matheus.png" alt="matheus" />
          <img src="./assets/img/lab01/img/img-vinicius.png" alt="vinicius" />
          <img src="./assets/img/lab01/img/img-viviane.png" alt="viviane" />
        </div>

        <h2>Análise e Conclusão</h2>

        <p class="longtext">
          As figuras geradas são simples, porem, são importantes para
          compreender o funcionamento básico de funções openGl e do fluxo de
          renderização. Peguemos o exemplo do Cubo, com a funçao
          <b>glBegin(GL_QUADS)</b> declaramos o inicio do desenho da forma, em
          seguida a função <b>glVertex3f()</b> é chamada 4 vezes para definir
          4 pontos no espaço 3D, formando uma área quadrada que é preenchida
          com cor pela função <b>glColor3f()</b>. Assim para formar o cubo,
          esse bloco de declarações é feito 6 vezes (1 para cada lado do cubo)
          em que mudamos é apenas os parametros de posição no espaço 3D.
          <br />Concluindo, o que temos é um padrão na programação de figuras
          simples que é replicavel para figuras mais complexas.
        </p>
      </div>
    </section>

    <section class="box-content" id="lab02">
      <div>
        <h2>Lab02: Introdução à Estrutura de OpenGL</h2>

        <h2>Exercício 1</h2>

        <p>
          A primeira coisa que tentamos para desenhar a primeira figura foi
          usar o comando <b>GL_POLYGON</b>, porém esse comando só funciona com
          polígonos convexos. Portanto, foi necessário desenhar a figura como
          combinação de tringulos e usar o comando <b>GL_TRIANGLES</b>. Para
          obter as coordenadas de cada triângulo criamos um desenho no site
          <a href="" target="_blank">Geograb 2D</a>
        </p>

        <p>
          Para obter as coordenadas primeiro reproduzimos os pontos no
          <a href="https://www.geogebra.org/m/Adc44ZZq" target="_blank">Geogebra 2D</a>
          e depois quebramos as figuras em 3 trinângulos como mostra a imagem
          a seguir.
        </p>

        <img src="./assets/img/lab02/img/geo2d.png" alt="geogreba 2d" />

        <p>
          Para encontrar a cor, usamos a ferramenta de color picker do Chrome
          e normalizamos a escala RGB para ficar entre 0 e 1 como exige o
          OpenGL.
        </p>
        <img src="./assets/img/lab02/img/cor.png" alt="color picker chrome" />

        <p>O código final ficou assim:</p>

        <p class="code">
          glBegin(GL_TRIANGLES);<br />
          glColor3f(.89, 1.0, 1.0);<br />
          glVertex3f(0.13, 0.73, 0.0); // p1 <br />
          glVertex3f(0.26, 0.33, 0.0); // p2 <br />
          glVertex3f(0.54, 0.61, 0.0); // p5 <br /><br />

          glVertex3f(0.26, 0.33, 0.0); // p2 <br />
          glVertex3f(0.95, 0.42, 0.0); // p3 <br />
          glVertex3f(0.54, 0.61, 0.0); // p5 <br /><br />

          glVertex3f(0.95, 0.42, 0.0); // p3 <br />
          glVertex3f(0.84, 0.88, 0.0); // p4 <br />
          glVertex3f(0.54, 0.61, 0.0); // p5 <br />
          glEnd();
        </p>

        <p>
          O código completo pode ser encontrado no seguinte link:
          <a href="https://github.com/ufabc-processamento-grafico/ufabc_pagina_processamento_grafico/blob/main/labs/lab02/5.1.cpp"
            target="_blank">https://github.com/ufabc-processamento-grafico/ufabc_pagina_processamento_grafico/blob/main/labs/lab02/5.1.cpp</a>
        </p>

        <p>Resultado:</p>
        <img src="./assets/img/lab02/img/ex1.png" alt="ex1 resultado" />

        <h2>Exercício 2</h2>

        <p>
          Para fazer o exercício 2, iniciamos de maneira bem semelhante ao
          exercício 1. Começamos buscando as cores com o color picker e
          mapeando os pontos.
        </p>

        <p>
          O OpenGL não cria círculos automaticamente, portanto foi necessário
          criar um looping usando a formula do círculo para gerar as figuras,
          fizemos isso usando o código a seguir:
        </p>

        <p class="code">
          GLdouble PI = 3.1415926535897;<br />
          GLint circle_points = 1000;<br />
          glBegin(GL_LINE_LOOP);<br />
          for (i = 0; i &lt; circle_points; i++)<br />
          {<br />
          &emsp;angle = 2 * PI * i / circle_points;<br />
          &emsp;glVertex2f(cos(angle), sin(angle));<br />
          }<br />
          glEnd();<br />
        </p>

        <p>
          As demais figuras foram criadas usando as primitivas básicas:
          <b>GL_POLYGON</b>, <b>GL_QUADS</b> e
          <b>GL_TRIANGLES</b>
        </p>

        <p>
          O código completo pode ser encontrado no seguinte link:
          <a href="https://github.com/ufabc-processamento-grafico/ufabc_pagina_processamento_grafico/blob/main/labs/lab02/5.2.cpp"
            target="_blank">https://github.com/ufabc-processamento-grafico/ufabc_pagina_processamento_grafico/blob/main/labs/lab02/5.2.cpp</a>
        </p>

        <p>
          Para compilar o código no Linux foi necessário agregar a flag
          <b>-lm</b> para linkar a <b>libm</b>
          que possuí métodos matemáticos usados para desenhar o círculo. O
          comando ficou assim:
        </p>

        <p class="code">gcc 5.2.cpp -lglut -lGL -lGLU -lm</p>

        <p>Resultado:</p>
        <img src="./assets/img/lab02/img/ex2.png" alt="ex2 resultado" />
      </div>
    </section>

    <section class="box-content" id="lab03">
      <div>
        <h2>Lab03: Modelagem e Transform2D</h2>

        <h3>1º. Projeto: “model.c”</h3>
        <img src="./assets/img/lab03/lab3_exemplo2-01.png" alt="model.cpp" style="width: 30%; height: 30%" />
        <p><b>Matriz Indentidade. Por que ela foi carregada?</b></p>
        <p>
          Para reinicializar a matriz de transformação e garantir que não
          vamos misturar com a anterior
        </p>

        <p>
          <b>Quais os valores dos argumentos das transformações realizadas?</b>
        </p>

        <p><b>Translação: T(dx, dy)</b></p>
        <p>(-20.0, 0.0)</p>

        <p><b>Escalonamento: S(sx, sy)</b></p>
        <p>(1.5, 0.5, 1.0)</p>

        <p><b>Rotação: R(⊝)</b></p>
        <p>(90.0, 0.0, 0.0, 1.0)</p>

        <p><b>Tecla para saída da execução do programa:</b></p>
        <p>ESC</p>

        <h3>2º. Projeto: “double.c”</h3>
        <img src="./assets/img/lab03/lab3_exemplo2-02.gif" alt="double.cpp" style="width: 30%; height: 30%" />
        <p><b>Guarda da Matriz na Pilha. Por que isso deve ser feito?</b></p>
        <p>
          Para conseguir concatenar facilmente transformações de diferentes
          matrizes e da mesma forma retirar transformações da stack antes de
          aplicar no próximo modelo.
        </p>

        <p>
          <b>. Qual o valor do angulo de Rotação: R(⊝) em cada
            apresentação?</b>
        </p>
        <p>(spin, 0.0, 0.0, 1.0)</p>
        <p>com spin alterando em 2.0 graus a cada apresentação.</p>

        <p>
          <b>Por que a animação (mudança do desenho na tela) ocorre no
            programa?</b>
        </p>
        <p>
          Porque chamamos a função spinDisplay para o método glutIdleFunc que
          fica executando em loop. Dentro da funçâo spinDisplay temos a
          chamada do método glutPostRedisplay que repinta a tela.
        </p>

        <h3>3º. Projeto: “rotacao.c”</h3>
        <img src="./assets/img/lab03/lab3_exemplo2-03.gif" alt="roracao.cpp" style="width: 30%; height: 30%" />
        <p><b>Rotação: R(⊝)</b></p>
        <p>(spin, 0.0, 0.0, 1.0)</p>
        <p>com spin alterando em 1.0 graus a cada apresentação.</p>

        <h3>4º. Projeto: “planet.c”</h3>
        <img src="./assets/img/lab03/lab3_exemplo2-04.gif" alt="planet.cpp" style="width: 30%; height: 30%" />
        <p>
          <b>Quais as transformações utilizadas para os dois tipos de
            movimento do planeta?</b>
        </p>
        <p>
          Para a rotação usamos glRotatef no mesmo eixo do planeta e para
          translação usamos glRotatef e glTranslatef.
        </p>

        <p>
          <b>Qual o valor do angulo de Rotação: R(⊝) em cada apresentação?</b>
        </p>
        <p>Rotação: (spin, 0.0, 1.0, 0.0)</p>
        <p>com spin alterando em 10.0 graus a cada apresentação.</p>
        <p>Translação: (spin, 0.0, 1.0, 0.0)</p>
        <p>com spin alterando em 5.0 graus a cada apresentação.</p>

        <h3>5º. Projeto: “robot.c”</h3>
        <p>
          <b>Qual a dimensão inicial de cada um dos objetos da cena?</b>
        </p>
        <p>Dimensão: (2.0, 0.4, 1.0)</p>
        <p>
          <b>Qual a finalidade de cada caso de uso da pilha (push e pop) no
            método “display”?</b>
        </p>

        <p>
          Temos no código que glPopMatrix() e glPushMatrix() são chamados
          separadamente para cada objeto (elbow e shouder), isso para que a
          transformacao de rotação ocorra de forma independente alterando o
          estado de um objeto por vez a partir do comando no teclado.
        </p>

        <p>
          <b>Grafo:</b>
        </p>
        <img src="./assets/img/lab03/robot.png" alt="robot" style="width: 40%; height: 40%" />

        <h2>Exercício 2</h2>

        <p>
          A primeira coisa que fizemos foi criar uma perpectiva paralela
          usando o comando <b>glOrtho</b> com as mesma dimensões da figura de
          referência. Dessa forma foi possível reutilizar as mesmas posições
          dos vértices da figura original.
        </p>

        <img src="./assets/img/lab03/ex-02-1.png" alt="figura original" />

        <p>
          O próximo passo foi desenhar a ponta esqurda da figura utilizando o
          comando
          <b>GL_TRIANGLE_STRIP</b>. A vantagem de usar o
          <b>GL_TRIANGLE_STRIP</b> é que reutilizamos vértices de triângulos
          adjacentes para criar os próximos triângulos, dessa maneira
          economizamos memória e deixamos o programa mais performático.
        </p>

        <p>
          Após criar o lado esquerdo da figura, separamos todo esse código em
          uma função com nome de
          <b>drawArrow</b> que é chamada novamente mais 3 vezes aplicando
          rotações de 90 graus. Dessa forma, foi possível reutilizar as mesmas
          coordenadas originais para desenhar o restante da figura. O
          resultado final está apresentado na imagem a seguir:
        </p>

        <img src="./assets/img/lab03/ex-02-2.png" alt="resultado" />

        <p>
          O próximo passo foi adicionar as funções <b>glutMouseFunc</b> para
          escutar os eventos do mouse e <b>glutSpecialFunc</b> para escutar os
          eventos do teclado. Deixamos os comandos da mesma forma uqe nos
          códigos do lab:
        </p>
        <ul>
          <li><b>Botão direito do mouse:</b> inicia a rotação</li>
          <li><b>Botão esquerdo ou central do mouse:</b> para a rotação</li>
          <li><b>F1:</b> Altera a cor para azul</li>
          <li><b>F2:</b> Altera a cor para verde</li>
          <li><b>F3:</b> Altera a cor para vermelho</li>
        </ul>

        <br />
        <br />

        <p>O resultado final está apresentado no GIF a seguir:</p>

        <img src="./assets/img/lab03/result.gif" alt="resultado" />

        <p>
          O código completo pode ser encontrado no seguinte link:
          <a href="https://github.com/ufabc-processamento-grafico/ufabc_pagina_processamento_grafico/blob/main/labs/lab03/lab03-02.cpp"
            target="_blank">https://github.com/ufabc-processamento-grafico/ufabc_pagina_processamento_grafico/blob/main/labs/lab03/lab03-02.cpp</a>
        </p>
      </div>
    </section>

    <section class="box-content" id="lab05">
      <div>
        <h2>Lab05: Cores e Misturas</h2>

        <h3>1º. Projeto: “smooth.c”</h3>
        <img src="./assets/img/lab05/01.png" alt="model.cpp" />
        <p><b>Qual o formato usado no comando glColor*() ?</b></p>
        <p>Float</p>

        <p>
          <b>Qual o efeito que ocorre quando cada vertice possui uma cor
            diferente?</b>
        </p>

        <p>As cores se misturam e vão mudando aos poucos entre os vertices</p>

        <h3>2º. Projeto: “alpha.c”</h3>
        <img src="./assets/img/lab05/02.png" alt="model.cpp" />

        <p>
          <b>Qual o valor de alpha?</b>
        </p>
        <p>0.75</p>

        <p>
          <b>Quais os parâmetros da função de mistura?</b>
        </p>
        <p>GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA</p>

        <p>
          <b>Qual a operação realizada no momento da mistura?</b>
        </p>
        <p>GL_FLAT</p>

        <h2>Exercício 1</h2>

        <p>
          A primeira coisa que fizemos foi criar o cubo usando o código
          disponibilizado no arquivo da primeira aula prática.
        </p>

        <p>
          Para definir as cores nos baseamos no cubo da aula teórica do slide
          a seguir:
        </p>

        <img src="./assets/img/lab05/03.png" alt="model.cpp" />

        <p>O resultado final pode ser visto a seguir:</p>

        <img src="./assets/img/lab05/04.png" alt="model.cpp" />

        <p>
          O código completo pode ser encontrado no seguinte link:
          <a href="https://github.com/ufabc-processamento-grafico/ufabc_pagina_processamento_grafico/blob/main/labs/lab05/ex1.c"
            target="_blank">https://github.com/ufabc-processamento-grafico/ufabc_pagina_processamento_grafico/blob/main/labs/lab05/ex1.c</a>
        </p>

        <h2>Exercício 2</h2>
        <p>
          Fazendo a inclusão de um objeto triangular de cor purple,
          conseguimos observar o comportamento da transparência e a
          importância das ordens, na figura abaixo a esquerda a ordem de
          posicionamento é purple, yellow e blue, sendo assim é possível
          observar que o blue faz a mistura de cores com os objetos atras
          dele, e o yellow faz com o purple que está atrás, já p/ a figura a
          direita, temos blue, yellow e purple, com isso as misturas são
          formadas de maneira diferente.
        </p>
        <div class="grid-imgs">
          <img src="./assets/img/lab05/05.png" alt="alpha-2.c" style="height: 50%; width: 50%" />
          <img src="./assets/img/lab05/06.png" alt="alpha-2.c" style="height: 50%; width: 50%" />
        </div>
        <p>
          O código completo pode ser encontrado no seguinte link:
          <a href="https://github.com/ufabc-processamento-grafico/ufabc_pagina_processamento_grafico/blob/main/labs/lab05/alpha-2.c"
            target="_blank">alpha-2.c</a>
        </p>
      </div>
    </section>

    <section class="box-content" id="lab06">
      <div>
        <h2>Lab06: Iluminação</h2>

        <h3>2º. Projeto: “material.c”</h3>
        <p><b>Quais os valores de propriedades da fonte de luz?</b></p>
        <p class="code">
          GLfloat ambient[] = { 0.0, 0.0, 0.0, 1.0 }; <br />
          GLfloat diffuse[] = { 1.0, 1.0, 1.0, 1.0 }; <br />
          GLfloat specular[] = { 1.0, 1.0, 1.0, 1.0 }; <br />
          GLfloat position[] = { 0.0, 3.0, 2.0, 0.0 }; <br />
          GLfloat lmodel_ambient[] = { 0.4, 0.4, 0.4, 1.0 }; <br />
          GLfloat local_view[] = { 0.0 }; <br />
        </p>

        <p>
          <b>O que foi habilitado no modelo de iluminação?</b>
        </p>

        <p class="code">
          glEnable(GL_LIGHTING);<br />
          glEnable(GL_LIGHT0);<br />
        </p>


        <p>
          <b>Quais os valores de propriedades dos materiais em cada caso das esferas?</b>
        </p>
        <p>Cada esfera usa uma combinação diferente das seguintes propriedades:</p>
        <p class="code">
          GLfloat no_mat[] = { 0.0, 0.0, 0.0, 1.0 };<br />
          GLfloat mat_ambient[] = { 0.7, 0.7, 0.7, 1.0 };<br />
          GLfloat mat_ambient_color[] = { 0.8, 0.8, 0.2, 1.0 };<br />
          GLfloat mat_diffuse[] = { 0.1, 0.5, 0.8, 1.0 };<br />
          GLfloat mat_specular[] = { 1.0, 1.0, 1.0, 1.0 };<br />
          GLfloat no_shininess[] = { 0.0 };<br />
          GLfloat low_shininess[] = { 5.0 };<br />
          GLfloat high_shininess[] = { 100.0 };<br />
          GLfloat mat_emission[] = {0.3, 0.2, 0.2, 0.0};<br />
        </p>

        <h3>3º. Projeto: “movelight.c”</h3>
        <p>
          <b>Quais os objetos desenhados?</b>
        </p>
        <p>Um toro sólido e as arestas de um cubo que acompanham a fonte de iluminação</p>

        <p><b>Como varia a posição da fonte de luz no programa?</b></p>
        <p>Conforme apertamos o botão esquerdo do mouse a luz rotaciona ao redor do sólido toro no eixo x.</p>

        <h2>Exercício 1</h2>

        <p>Criamos uma nova luz bem no centro da esfera que agora tem iluminação especular mais avermelhada</p>
        <img src="./assets/img/lab06/ex1.png" alt="alpha-2.c" style="height: 50%; width: 50%" />

        <p>
          O código completo pode ser encontrado no seguinte link:
          <a href="https://github.com/ufabc-processamento-grafico/ufabc_pagina_processamento_grafico/blob/main/labs/lab06/ex1.c"
            target="_blank">https://github.com/ufabc-processamento-grafico/ufabc_pagina_processamento_grafico/blob/main/labs/lab06/ex1.c</a>
        </p>

        <h2>Exercício 3</h2>

        <p>Criamos um cubo em um cone com propriedades totalmente diferentes. A mudança de posicionamento da luz
          evidencia isso e mostra também que o cone consegue emitir sua própria luz.</p>
        <img src="./assets/img/lab06/ex3-1.png" alt="alpha-2.c" style="height: 50%; width: 50%" />
        <img src="./assets/img/lab06/ex3-2.png" alt="alpha-2.c" style="height: 50%; width: 50%" />

        <p>
          O código completo pode ser encontrado no seguinte link:
          <a href="https://github.com/ufabc-processamento-grafico/ufabc_pagina_processamento_grafico/blob/main/labs/lab06/ex3.c"
            target="_blank">https://github.com/ufabc-processamento-grafico/ufabc_pagina_processamento_grafico/blob/main/labs/lab06/ex3.c</a>
        </p>
      </div>
    </section>

    <section class="box-content" id="lab07">
      <div>
        <h2>Lab07: Mapeamento de Textura</h2>


      </div>
    </section>
  </div>
</body>

</html>